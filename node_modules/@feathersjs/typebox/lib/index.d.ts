import { TObject, TInteger, TOptional, TSchema, TIntersect } from '@sinclair/typebox';
import { Validator, DataValidatorMap, Ajv } from '@feathersjs/schema';
export * from '@sinclair/typebox';
export * from './default-schemas';
export declare type TDataSchemaMap = {
    create: TObject;
    update?: TObject;
    patch?: TObject;
};
/**
 * Returns a compiled validation function for a TypeBox object and AJV validator instance.
 *
 * @param schema The JSON schema definition
 * @param validator The AJV validation instance
 * @returns A compiled validation function
 */
export declare const getValidator: <T = any, R = T>(schema: TObject, validator: Ajv) => Validator<T, R>;
/**
 * Returns compiled validation functions to validate data for the `create`, `update` and `patch`
 * service methods. If not passed explicitly, the `update` validator will be the same as the `create`
 * and `patch` will be the `create` validator with no required fields.
 *
 * @param def Either general TypeBox object definition or a mapping of `create`, `update` and `patch`
 * to their respective type object
 * @param validator The Ajv instance to use as the validator
 * @returns A map of validator functions
 */
export declare const getDataValidator: (def: TObject | TDataSchemaMap, validator: Ajv) => DataValidatorMap;
export declare function sortDefinition<T extends TObject>(schema: T): TObject<T["properties"] extends infer T_1 ? { [K in keyof T_1]: TOptional<TInteger>; } : never>;
export declare const queryProperty: <T extends TSchema>(def: T) => TOptional<import("@sinclair/typebox").TUnion<[T, TObject<{
    $gt: TOptional<T>;
    $gte: TOptional<T>;
    $lt: TOptional<T>;
    $lte: TOptional<T>;
    $ne: TOptional<T>;
    $in: TOptional<import("@sinclair/typebox").TArray<T>>;
    $nin: TOptional<import("@sinclair/typebox").TArray<T>>;
}>]>>;
export declare const queryProperties: <T extends TObject<import("@sinclair/typebox").TProperties>>(type: T) => TObject<T["properties"] extends infer T_1 ? { [K in keyof T_1]: TOptional<import("@sinclair/typebox").TUnion<[T["properties"][K], TObject<{
    $gt: TOptional<T["properties"][K]>;
    $gte: TOptional<T["properties"][K]>;
    $lt: TOptional<T["properties"][K]>;
    $lte: TOptional<T["properties"][K]>;
    $ne: TOptional<T["properties"][K]>;
    $in: TOptional<import("@sinclair/typebox").TArray<T["properties"][K]>>;
    $nin: TOptional<import("@sinclair/typebox").TArray<T["properties"][K]>>;
}>]>>; } : never>;
/**
 * Creates a TypeBox schema for the complete Feathers query syntax including `$limit`, $skip`
 * and `$sort` and `$select` for the allowed properties.
 *
 * @param type The properties to create the query syntax for
 * @returns A TypeBox object representing the complete Feathers query syntax for the given properties
 */
export declare const querySyntax: <T extends TObject<import("@sinclair/typebox").TProperties> | TIntersect<TObject<import("@sinclair/typebox").TProperties>[]>>(type: T) => TIntersect<[TObject<{
    $limit: TOptional<import("@sinclair/typebox").TNumber>;
    $skip: TOptional<import("@sinclair/typebox").TNumber>;
    $sort: TOptional<TObject<T["properties"] extends infer T_1 ? { [K in keyof T_1]: TOptional<TInteger>; } : never>>;
    $select: TOptional<import("@sinclair/typebox").TUnsafe<(keyof T["properties"])[]>>;
}>, TObject<T["properties"] extends infer T_2 ? { [K_1 in keyof T_2]: TOptional<import("@sinclair/typebox").TUnion<[T["properties"][K_1], TObject<{
    $gt: TOptional<T["properties"][K_1]>;
    $gte: TOptional<T["properties"][K_1]>;
    $lt: TOptional<T["properties"][K_1]>;
    $lte: TOptional<T["properties"][K_1]>;
    $ne: TOptional<T["properties"][K_1]>;
    $in: TOptional<import("@sinclair/typebox").TArray<T["properties"][K_1]>>;
    $nin: TOptional<import("@sinclair/typebox").TArray<T["properties"][K_1]>>;
}>]>>; } : never>]>;
