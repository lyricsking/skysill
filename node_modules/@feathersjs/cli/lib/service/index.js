"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generate = void 0;
const lodash_1 = __importDefault(require("lodash"));
const pinion_1 = require("@feathershq/pinion");
const commons_1 = require("../commons");
const generate = (ctx) => (0, pinion_1.generator)(ctx)
    .then((0, commons_1.initializeBaseContext)())
    .then((0, commons_1.checkPreconditions)())
    .then((0, pinion_1.prompt)(({ name, path, type, schema, authentication, isEntityService, feathers }) => [
    {
        name: 'name',
        type: 'input',
        when: !name,
        message: 'What is the name of your service?',
        validate: (input) => {
            if (!input || input === 'authentication') {
                return 'Invalid service name';
            }
            return true;
        }
    },
    {
        name: 'path',
        type: 'input',
        when: !path,
        message: 'Which path should the service be registered on?',
        default: (answers) => `${lodash_1.default.kebabCase(answers.name)}`,
        validate: (input) => {
            if (!input || input === 'authentication') {
                return 'Invalid service path';
            }
            return true;
        }
    },
    {
        name: 'authentication',
        type: 'confirm',
        when: authentication === undefined && !isEntityService,
        message: 'Does this service require authentication?'
    },
    {
        name: 'type',
        type: 'list',
        when: !type,
        message: 'What kind of service is it?',
        default: (0, commons_1.getDatabaseAdapter)(feathers === null || feathers === void 0 ? void 0 : feathers.database),
        choices: [
            {
                value: 'knex',
                name: 'SQL'
            },
            {
                value: 'mongodb',
                name: 'MongoDB'
            },
            {
                value: 'custom',
                name: 'A custom service'
            }
        ]
    },
    {
        name: 'schema',
        type: 'list',
        when: schema === undefined,
        message: 'Which schema definition format do you want to use?',
        default: feathers === null || feathers === void 0 ? void 0 : feathers.schema,
        choices: [
            {
                value: 'typebox',
                name: 'TypeBox'
            },
            {
                value: 'json',
                name: 'JSON schema'
            },
            {
                value: false,
                name: 'No schema'
            }
        ]
    }
]))
    .then(async (ctx) => {
    const { name, path, type } = ctx;
    const kebabName = lodash_1.default.kebabCase(name);
    const camelName = lodash_1.default.camelCase(name);
    const upperName = lodash_1.default.upperFirst(camelName);
    const className = `${upperName}Service`;
    const folder = path.split('/').filter((el) => el !== '');
    const relative = ['', ...folder].map(() => '..').join('/');
    const fileName = lodash_1.default.last(folder);
    const kebabPath = lodash_1.default.kebabCase(path);
    return {
        name,
        type,
        path,
        folder,
        fileName,
        upperName,
        className,
        kebabName,
        camelName,
        kebabPath,
        relative,
        ...ctx
    };
})
    .then((0, pinion_1.runGenerators)(__dirname, 'templates'))
    .then((0, pinion_1.runGenerator)(__dirname, 'type', ({ type }) => `${type}.tpl`));
exports.generate = generate;
//# sourceMappingURL=index.js.map